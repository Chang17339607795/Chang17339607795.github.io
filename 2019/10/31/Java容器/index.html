<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="C">
    
    
    
    
    
    
    <title>Hexo</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
</head></html>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="lrc-control">Open Lyrics</a>
        </li>
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" http://cube-1252774894.cosgz.myqcloud.com/background.jpg " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">世界上对勇气的最大考验是忍受失败而不丧失信心。</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('http://cube-1252774894.cosgz.myqcloud.com/background.jpg');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('http://cube-1252774894.cosgz.myqcloud.com/background.jpg');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">世界上对勇气的最大考验是忍受失败而不丧失信心。</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            <div class="cube-article">
    <h1 class="title"></h1>
    
    <div class="cube-article-header">
        <div class="cube-article-date">
            <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
            <!-- moment.js对象 -->
            2019-10-31
        </div>
        <div class="cube-article-tags">
    <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
    
</div>
    </div>
    
    <div class="cube-article-content cube-markdown">
        
        <h2 id="Java集合类框架图"><a href="#Java集合类框架图" class="headerlink" title="Java集合类框架图"></a>Java集合类框架图</h2><p><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-16.png" alt></p>
<h2 id="HashSet和TreeSet区别"><a href="#HashSet和TreeSet区别" class="headerlink" title="HashSet和TreeSet区别"></a>HashSet和TreeSet区别</h2><p><strong>HashSet</strong></p>
<ol>
<li>不能保证元素的排列顺序，顺序有可能发生变化</li>
<li>不是同步的</li>
<li>集合元素可以是null,但只能放入一个null<br>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。</li>
</ol>
<p><strong>TreeSet</strong></p>
<ol>
<li>TreeSet是SortedSet接口的唯一实现类</li>
<li>TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象</li>
</ol>
<h2 id="讲一下LinkedHashMap"><a href="#讲一下LinkedHashMap" class="headerlink" title="讲一下LinkedHashMap"></a>讲一下LinkedHashMap</h2><p>LinkedHashMap的实现就是HashMap+LinkedList的实现方式，以HashMap维护数据结构，以LinkList的方式维护数据插入顺序</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。<br>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器</p>
<p>利用LinkedHashMap实现LRU算法缓存（</p>
<ol>
<li>LinkedList首先它是一个Map，Map是基于K-V的，和缓存一致</li>
<li>LinkedList提供了一个boolean值可以让用户指定是否实现LRU）</li>
</ol>
<h2 id="Java8-中HashMap的优化（引入红黑树的数据结构和扩容的优化）"><a href="#Java8-中HashMap的优化（引入红黑树的数据结构和扩容的优化）" class="headerlink" title="Java8 中HashMap的优化（引入红黑树的数据结构和扩容的优化）"></a>Java8 中HashMap的优化（引入红黑树的数据结构和扩容的优化）</h2><ol>
<li>if (binCount &gt;= TREEIFY_THRESHOLD - 1)<br>当符合这个条件的时候，把链表变成treemap红黑树，这样查找效率从o(n)变成了o(log n) ，在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：</li>
<li>我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</li>
</ol>
<p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p><strong>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</strong><br>hashMap 1.8 哈希算法例图2<br><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-2.jpg" alt><br><strong>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong></p>
<h2 id="Map遍历的keySet-和entrySet-性能差异原因"><a href="#Map遍历的keySet-和entrySet-性能差异原因" class="headerlink" title="Map遍历的keySet()和entrySet()性能差异原因"></a>Map遍历的keySet()和entrySet()性能差异原因</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Set&lt;String&gt; set = map.keySet();`</span><br></pre></td></tr></table></figure>

<ol>
<li>keySet（）循环中通过key获取对应的value的时候又会调用getEntry（）进行循环。循环两次</li>
<li>entrySet（）直接使用getEntry（）方法获取结果，循环一次</li>
<li>所以 keySet（）的性能会比entrySet（）差点。所以遍历map的话还是用entrySet()来遍历<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap中的indexFor方法"><a href="#HashMap中的indexFor方法" class="headerlink" title="HashMap中的indexFor方法"></a>HashMap中的indexFor方法</h2><p>在HashMap的工作原理，发现它调用了 indexFor(int h, int length) 方法来计算Entry对象保存在 table中的数组索引值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap的初始容量和扩容都是以2的次方来进行的，那么length-1换算成二进制的话肯定所有位都为1，就比如2的3次方为8，length-1的二进制表示就是111， 而按位与计算的原则是两位同时为“1”，结果才为“1”，否则为“0”。所以h&amp; (length-1)运算从数值上来讲其实等价于对length取模，也就是h%length。</p>
<p>只有当数组长度为2的n次方时，那么length-1换算成二进制的话肯定所有位都为1,不同的key计算得出的index索引相同的几率才会较小，数据在数组上分布也比较均匀，碰撞的几率也小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<h2 id="如何删除ArrayList里面的元素"><a href="#如何删除ArrayList里面的元素" class="headerlink" title="如何删除ArrayList里面的元素"></a>如何删除ArrayList里面的元素</h2><p>使用以下for循环使用remove()删除是有问题的，因为每次删除一个元素，后面元素往前移，数组大小也变小，会到数组下标越界异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; list1.size();i++)&#123;</span><br><span class="line">            list1.remove(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>推荐两种方法：</p>
<ol>
<li><p>根据长度，不断删除第一个元素，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; list1.size();i++)&#123;</span><br><span class="line">            list1.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用迭代器(推荐)，不会导致数组长度变化而抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iter = list1.iterator();</span><br><span class="line">     <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">         Integer s = iter.next();</span><br><span class="line">         <span class="keyword">if</span>(s.equals(<span class="string">"1"</span>))&#123;</span><br><span class="line">             iter.remove();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="并发的HashMap为什么会引起死循环？"><a href="#并发的HashMap为什么会引起死循环？" class="headerlink" title="并发的HashMap为什么会引起死循环？"></a>并发的HashMap为什么会引起死循环？</h2><p>线程不安全的HashMap, HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，查找时会陷入死循环</p>
<p>在扩容resize（）方法中，调用transfer方法，把旧表中的元素添加到新表中，这也是引起死循环的根本原因所在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; <span class="comment">// &lt;--假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>执行一：  线程A执行到transfer函数中（1）处挂起（transfer函数代码中有标注）。此时在线程A的栈中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">3</span></span><br><span class="line">next = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>执行二：线程B执行 transfer函数中的while循环，即会把原来的table变成新一table（线程B自己的栈中），再写入到内存,如下图（假设两个元素在新的hash函数下也会映射到同一个位置）<br><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-9.jpg" alt></p>
<p>执行三： 线程A解挂，接着执行（看到的仍是旧表），即从transfer代码（1）处接着执行，当前的 e = 3, next = 7, 上面已经描述。</p>
<ol>
<li>处理元素 3 ， 将 3 放入 线程A自己栈的新table中（新table是处于线程A自己栈中，是线程私有的，不肥线程2的影响），处理3后的图如下：<br><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-10.jpg" alt></li>
<li>线程A再复制元素 7 ， <strong>当前 e = 7 ,而next值由于线程 B 修改了它的引用，所以next 为 3</strong> ，处理后的新表如下图<br><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-11.jpg" alt></li>
<li>由于上面取到的next = 3, 接着while循环，即当前处理的结点为3， next就为null ，退出while循环，执行完while循环后，新表中的内容如下图：<br><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-12.jpg" alt></li>
<li>当操作完成，执行查找时，会陷入死循环！</li>
</ol>
<p>总结：多线程PUT操作时可能会覆盖刚PUT进去的值,扩容操作会让链表形成环形数据结构，形成死循环</p>
<h2 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h2><p>HashTable 在每次同步执行时都要锁住整个结构。ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值）</p>
<p>Java7<br><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-13.jpg" alt></p>
<p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。</p>
<p>Java8<br><img src="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Java-14.jpg" alt><br>Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))</p>
<p>Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。</p>
<p>对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</p>
<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><h3 id="HashMap特性"><a href="#HashMap特性" class="headerlink" title="HashMap特性"></a>HashMap特性</h3><p>HashMap的特性：HashMap存储键值对，实现快速存取数据；允许null键/值；非同步；不保证有序(比如插入的顺序)。实现map接口。</p>
<h3 id="HashMap的原理，内部数据结构"><a href="#HashMap的原理，内部数据结构" class="headerlink" title="HashMap的原理，内部数据结构"></a>HashMap的原理，内部数据结构</h3><p>HashMap是基于hashing的原理，底层使用哈希表（数组 + 链表）实现。里边最重要的两个方法put、get，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。 </p>
<p>存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<h3 id="讲一下-HashMap-中-put-方法过程"><a href="#讲一下-HashMap-中-put-方法过程" class="headerlink" title="讲一下 HashMap 中 put 方法过程"></a>讲一下 HashMap 中 put 方法过程</h3><ol>
<li>对key的hashCode做hash操作，然后再计算在bucket中的index（1.5 HashMap的哈希函数）； </li>
<li>如果没碰撞直接放到bucket里； </li>
<li>如果碰撞了，以链表的形式存在buckets后； </li>
<li>如果节点已经存在就替换old value(保证key的唯一性) </li>
<li>如果bucket满了(超过阈值，阈值=loadfactor*current capacity，load factor默认0.75)，就要resize。</li>
</ol>
<h3 id="get-方法的工作原理"><a href="#get-方法的工作原理" class="headerlink" title="get()方法的工作原理"></a>get()方法的工作原理</h3><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表中查找对应的节点。</p>
<h3 id="HashMap中hash函数怎么是是实现的？还有哪些-hash-的实现方式？"><a href="#HashMap中hash函数怎么是是实现的？还有哪些-hash-的实现方式？" class="headerlink" title="HashMap中hash函数怎么是是实现的？还有哪些 hash 的实现方式？"></a>HashMap中hash函数怎么是是实现的？还有哪些 hash 的实现方式？</h3><ol>
<li>对key的hashCode做hash操作（高16bit不变，低16bit和高16bit做了一个异或）； </li>
<li>h &amp; (length-1); //通过位操作得到下标index。</li>
</ol>
<p>还有数字分析法、平方取中法、分段叠加法、 除留余数法、 伪随机数法。</p>
<h3 id="HashMap-怎样解决冲突？"><a href="#HashMap-怎样解决冲突？" class="headerlink" title="HashMap 怎样解决冲突？"></a>HashMap 怎样解决冲突？</h3><p>HashMap中处理冲突的方法实际就是链地址法，内部数据结构是数组+单链表。</p>
<h4 id="扩展问题1：当两个对象的hashcode相同会发生什么？"><a href="#扩展问题1：当两个对象的hashcode相同会发生什么？" class="headerlink" title="扩展问题1：当两个对象的hashcode相同会发生什么？"></a>扩展问题1：当两个对象的hashcode相同会发生什么？</h4><p>因为两个对象的Hashcode相同，所以它们的bucket位置相同，会发生“碰撞”。HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p>
<h4 id="扩展问题2：抛开-HashMap，hash-冲突有那些解决办法？"><a href="#扩展问题2：抛开-HashMap，hash-冲突有那些解决办法？" class="headerlink" title="扩展问题2：抛开 HashMap，hash 冲突有那些解决办法？"></a>扩展问题2：抛开 HashMap，hash 冲突有那些解决办法？</h4><p>开放定址法、链地址法、再哈希法。</p>
<h3 id="如果两个键的hashcode相同，你如何获取值对象？"><a href="#如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="如果两个键的hashcode相同，你如何获取值对象？"></a>如果两个键的hashcode相同，你如何获取值对象？</h3><p>重点在于理解hashCode()与equals()。 </p>
<p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。两个键的hashcode相同会产生碰撞，则利用key.equals()方法去链表或树（java1.8）中去查找对应的节点。</p>
<h3 id="针对-HashMap-中某个-Entry-链太长，查找的时间复杂度可能达到-O-n-，怎么优化？"><a href="#针对-HashMap-中某个-Entry-链太长，查找的时间复杂度可能达到-O-n-，怎么优化？" class="headerlink" title="针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？"></a>针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？</h3><p>将链表转为红黑树，实现 O(logn) 时间复杂度内查找。JDK1.8 已经实现了。</p>
<h3 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h3><p>扩容。这个过程也叫作rehashing，因为它重建内部数据结构，并调用hash方法找到新的bucket位置。 大致分两步： </p>
<ol>
<li>扩容：容量扩充为原来的两倍（2 * table.length）； </li>
<li>移动：对每个节点重新计算哈希值，重新计算每个元素在数组中的位置，将原来的元素移动到新的哈希表中。<br>　　<br>补充： </li>
<li>loadFactor：加载因子。默认值DEFAULT_LOAD_FACTOR = 0.75f； </li>
<li>capacity：容量； </li>
<li>threshold：阈值=capacity<em>loadFactor。当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍（capacity</em>2）； </li>
<li>size：HashMap的大小，它是HashMap保存的键值对的数量。</li>
</ol>
<h3 id="为什么String-Interger这样的类适合作为键？"><a href="#为什么String-Interger这样的类适合作为键？" class="headerlink" title="为什么String, Interger这样的类适合作为键？"></a>为什么String, Interger这样的类适合作为键？</h3><p>　　String, Interger这样的类作为HashMap的键是再适合不过了，而且String最为常用。<br>　　因为String对象是不可变的，而且已经重写了equals()和hashCode()方法了。<br>　　1.不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。<br>　　注：String的不可变性可以看这篇文章《【java基础】浅析String》。<br>　　2.因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p>
<h2 id="HashMap与HashTable区别"><a href="#HashMap与HashTable区别" class="headerlink" title="HashMap与HashTable区别"></a>HashMap与HashTable区别</h2><p>　　Hashtable可以看做是线程安全版的HashMap，两者几乎“等价”（当然还是有很多不同）。Hashtable几乎在每个方法上都加上synchronized（同步锁），实现线程安全。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>HashMap继承于AbstractMap，而Hashtable继承于Dictionary； </li>
<li>线程安全不同：Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理； </li>
<li>null值：HashMap的key、value都可以为null。Hashtable的key、value都不可以为null； </li>
<li>迭代器(Iterator)：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException。 </li>
<li>容量的初始值和增加方式都不一样：HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”； </li>
<li>添加key-value时的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法。Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。 </li>
<li>速度。由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>
</ol>
<h3 id="能否让HashMap同步？"><a href="#能否让HashMap同步？" class="headerlink" title="能否让HashMap同步？"></a>能否让HashMap同步？</h3><p>　　HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap);</p>

    </div>
</div>

<div class="cube-article-nav">
    <ul>
        
        <li class="prev">
            <a href="/2019/10/31/Java并发/">
                <i class="cube-icon cube-prev" aria-hidden="true"></i>
                
            </a>
        </li>
        
        
        <li class="next">
            <a href="/2019/10/31/JAVA知识点/">
                
                <i class="cube-icon cube-next" aria-hidden="true"></i>
            </a>
        </li>
        
    </ul>
</div>


<!-- TODO 根据theme.comment的内容进行入口选择 -->



        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>C</span>
    
    
    <div class="count">
        <a class="count articles"><span>6</span>Article</a>
        <a class="count tags"><span>0</span>Tags</a>
        <a class="count categories"><span>0</span>Categories</a>
    </div>
</div>



<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":false,"showlrc":3,"theme":"#b7daff","mutex":true,"mode":"circulation","preload":"auto","listmaxheight":"513px","music":[{"title":"Dear friends","author":"TRIPLANE","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/TRIPLANE - Dear friends.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Dear friends - TRIPLANE.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/TRIPLANE - Dear friends.jpg"},{"title":"Butter-Fly","author":"和田光司","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/和田光司 - Butter-Fly (ピアノヴァージョン).mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Butter-Fly (ピアノヴァージョン) - 和田光司.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/和田光司 - Butter-Fly (ピアノヴァージョン).jpg"},{"title":"宵闇花火","author":"葉月ゆら","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/葉月ゆら - 宵闇花火.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/宵闇花火 - 葉月ゆら.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/葉月ゆら - 宵闇花火.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: 'Open Lyrics',
            close: 'Close Lyrics'
        }
    })(window)
</script>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2019/10/31/Java虚拟机/" title=""></a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2019/10/31/Java并发/" title=""></a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2019/10/31/Java容器/" title=""></a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2019/10/31/JAVA知识点/" title=""></a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2019/10/20/MySQL数据库知识点/" title=""></a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>







<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/ZEROKISEKI" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/Coding.png">
            
            <a href="https://coding.net/u/SORA1" target="_blank">Coding</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/SF.png">
            
            <a href="https://segmentfault.com/u/aonosora" target="_blank">SF社区</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/开发者头条.png">
            
            <a href="https://toutiao.io/u/148070" target="_blank">开发者头条</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/micblo.png">
            <a href="https://blog.micblo.com/" target="_blank">罗大佬</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/DIYgod.jpg">
            <a href="https://www.anotherhome.net/" target="_blank">DIYgod</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/friend_links.jpg ">
            <a href="https://aonosora.com/" target="_blank">C</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 C

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>